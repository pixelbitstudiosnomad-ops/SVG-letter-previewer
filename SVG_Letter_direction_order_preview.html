<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Letter SVG Previewer â€” Final Fixed</title>
<style>
:root{
  --bg:#0f1115; --panel:#16171a; --accent:#00e0ff; --text:#e6eef1;
  --btn-glow:0 6px 28px rgba(0,224,255,0.12);
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;background:var(--bg);color:var(--text);font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system;}
.app{display:flex;flex-direction:row;height:100vh;padding:14px;overflow:hidden;gap:10px}
.left{width:38%;display:flex;flex-direction:column;gap:12px;min-width:260px}
.right{flex:1;display:flex;flex-direction:column;min-width:420px}
.panel{background:var(--panel);border-radius:10px;padding:12px;display:flex;flex-direction:column;gap:8px}
h2{color:var(--accent);text-align:center;margin:0}
input[type="file"]::file-selector-button, button {
  border-radius:8px;border:none;background:linear-gradient(180deg,#00e0ff,#00b8d9);
  color:#001214;padding:8px 12px;font-weight:700;cursor:pointer;box-shadow:var(--btn-glow)
}
input[type="file"]{background:#101217;padding:6px;border-radius:8px;border:1px solid #222;color:var(--text)}
textarea,input[type="text"]{width:100%;background:rgba(255,255,255,0.03);border:1px solid #222;padding:8px;border-radius:8px;color:var(--text)}
.path-list{display:flex;flex-direction:column;gap:8px;overflow:hidden}
.path-item{display:flex;align-items:center;gap:10px;padding:8px;border-radius:8px;background:#0e0f11;border:1px solid rgba(255,255,255,0.03);cursor:grab;user-select:none}
.path-item.dragging{opacity:.5}
.color-dot{width:16px;height:16px;border-radius:50%}
.controls{display:flex;gap:6px}
.controls button{padding:6px 8px;background:#101217;border:1px solid #222;color:var(--accent);border-radius:6px}
.drop-indicator{position:absolute;left:0;right:0;height:4px;background:var(--accent);border-radius:3px;box-shadow:0 0 8px #00e0ffaa;pointer-events:none}
.preview-wrap{flex:1;display:flex;flex-direction:column;gap:8px;overflow:hidden}
.preview-box{flex:1;display:flex;align-items:center;justify-content:center;border-radius:10px;background:#0b0b0c;padding:8px;overflow:hidden}
#preview{width:100%;height:100%;display:block;margin:auto;align-self:center;justify-self:center;}
.resize-vertical{height:8px;background:linear-gradient(90deg,transparent,#00e0ff44,transparent);cursor:row-resize;border-radius:6px}
.json-box{flex:1;display:flex;flex-direction:column;gap:8px;height:50%}
pre.json{flex:1;background:#060607;color:#9bffde;padding:10px;border-radius:8px;overflow:auto;margin:0}
.small-muted{color:#9aa6a9;font-size:13px}
.range-num{width:48px;text-align:center;padding:6px;border-radius:6px;background:#0b0c0d;color:#bfecea}
#hDivider{width:8px;cursor:col-resize;background:linear-gradient(180deg,transparent,#00e0ff44,transparent);border-radius:6px}
</style>
</head>
<body>
<div class="app" id="appContainer">
  <div class="left" id="leftPanel">
    <!-- Upload / Paste -->
    <div class="panel" id="panel-upload">
      <h2>Letter SVG Previewer</h2>
      <div style="display:flex;gap:8px;">
        <input id="fileInput" type="file" accept=".svg,.json">
        <input id="charInput" type="text" placeholder="Character (e.g. à¤¨à¤¾)">
      </div>
      <textarea id="pasteArea" placeholder="Paste SVG markup or JSON with trace_path array here"></textarea>
      <div style="display:flex;gap:8px;flex-wrap:wrap;">
        <button id="importBtn">Import</button>
        <button id="undoBtn">â†© Undo</button>
        <button id="resetBtn">â†º Reset</button>
        <button id="clearBtn">ðŸ—‘ Clear</button>
      </div>
    </div>

    <!-- Stroke List -->
    <div class="panel" id="panel-strokes" style="position:relative;">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Stroke List</strong>
        <div class="small-muted">Drag to reorder â€¢ up/down â€¢ reverse</div>
      </div>
      <div id="pathList" class="path-list" aria-live="polite"></div>
    </div>

    <!-- Display Settings (moved BELOW strokes) -->
    <div class="panel" id="panel-display">
      <strong>Display Settings</strong>
      <div style="display:flex;align-items:center;gap:10px;">
        <label>Stroke Width</label>
        <input id="strokeRange" type="range" min="1" max="50" step="0.5" value="1" style="flex:1">
        <div id="strokeValue" class="range-num">1</div>
      </div>
      <div style="display:flex;align-items:center;gap:10px;">
        <label>Viewport BG</label>
        <input id="bgColor" type="color" value="#0d0d0d">
        <div style="flex:1"></div>
        <label>Show Arrows</label>
        <input id="showArrows" type="checkbox" checked>
      </div>
    </div>
  </div>

  <!-- Horizontal divider (resizer) -->
  <div id="hDivider"></div>

  <!-- Right side -->
  <div class="right" id="rightPanel">
    <div class="panel preview-wrap" style="padding:8px;">
      <strong>Preview</strong>
      <div id="previewContainer" class="preview-box" style="height:50%;">
        <svg id="preview" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>

      <div id="vDivider" class="resize-vertical"></div>

      <div class="json-box" style="height:50%;">
        <strong>Live JSON</strong>
        <pre id="jsonOutput" class="json">{ "char": " ", "trace_path": [] }</pre>
        <div style="display:flex;justify-content:flex-end;">
          <button id="copyJson">Copy JSON</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ====== State & elements ====== */
const colors=["red","green","blue","yellow","black","pink","orange","cyan"];
const darkOverlay=new Set(["red","blue","green","black"]);
let paths=[], originalPaths=[], undoStack=[];
let strokeW=1, bg="#0d0d0d", showArrows=true;

const fileInput=document.getElementById('fileInput');
const pasteArea=document.getElementById('pasteArea');
const importBtn=document.getElementById('importBtn');
const undoBtn=document.getElementById('undoBtn');
const resetBtn=document.getElementById('resetBtn');
const clearBtn=document.getElementById('clearBtn');
const charInput=document.getElementById('charInput');
const pathList=document.getElementById('pathList');
const preview=document.getElementById('preview');
const jsonOutput=document.getElementById('jsonOutput');
const copyJson=document.getElementById('copyJson');
const strokeRange=document.getElementById('strokeRange');
const strokeValue=document.getElementById('strokeValue');
const bgColor=document.getElementById('bgColor');
const showArrowsInput=document.getElementById('showArrows');
const hDivider=document.getElementById('hDivider');
const leftPanel=document.getElementById('leftPanel');
const rightPanel=document.getElementById('rightPanel');
const previewContainer=document.getElementById('previewContainer');
const vDivider=document.getElementById('vDivider');

/* ====== Helpers ====== */
function saveUndo(){ undoStack.push(JSON.stringify(paths)); if(undoStack.length>80) undoStack.shift(); }
function updateJson(){ jsonOutput.textContent = JSON.stringify({ char: charInput.value || " ", trace_path: paths }, null, 2); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* ====== Import (file / paste / JSON) ====== */
fileInput.addEventListener('change', e=>{
  const f = e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ev => importInput(ev.target.result);
  r.readAsText(f);
});
importBtn.addEventListener('click', ()=> importInput(pasteArea.value.trim()));

function importInput(text){
  if(!text) return;
  saveUndo();
  paths = []; originalPaths = [];
  try{
    const j = JSON.parse(text);
    if(j.trace_path && Array.isArray(j.trace_path)){
      paths = j.trace_path.slice();
      originalPaths = paths.slice();
      if(j.char) charInput.value = j.char;
      renderAll();
      return;
    }
  }catch(e){}
  // parse svg markup
  const doc = new DOMParser().parseFromString(text, 'image/svg+xml');
  let nodes = doc.querySelectorAll('path,line');
  if(nodes.length === 0){
    // try wrap
    const doc2 = new DOMParser().parseFromString(`<svg>${text}</svg>`, 'image/svg+xml');
    nodes = doc2.querySelectorAll('path,line');
  }
  nodes.forEach(el=>{
    if(el.tagName === 'path') paths.push(el.getAttribute('d'));
    else paths.push(`M${el.getAttribute('x1')},${el.getAttribute('y1')} L${el.getAttribute('x2')},${el.getAttribute('y2')}`);
  });
  originalPaths = paths.slice();
  renderAll();
}

/* ====== Stroke list rendering & drag/drop ====== */
function renderList(){
  pathList.innerHTML = '';
  paths.forEach((d,i)=>{
    const row = document.createElement('div');
    row.className = 'path-item';
    row.draggable = true;
    row.dataset.index = i;
    row.innerHTML = `
      <div class="color-dot" style="background:${colors[i%colors.length]}"></div>
      <div style="flex:1;overflow:hidden;white-space:nowrap;text-overflow:ellipsis">Stroke ${i+1}</div>
      <div class="controls">
        <button onclick="moveUp(${i})">â–²</button>
        <button onclick="moveDown(${i})">â–¼</button>
        <button onclick="reversePath(${i})">â†”</button>
        <button onclick="deletePath(${i})">âœ–</button>
      </div>`;
    row.addEventListener('dragstart', e=>{
      e.dataTransfer.setData('text/plain', row.dataset.index);
      e.dataTransfer.effectAllowed = 'move';
      row.classList.add('dragging');
      // reduce text selection while dragging
      document.body.style.userSelect = 'none';
    });
    row.addEventListener('dragend', e=>{
      row.classList.remove('dragging');
      removeIndicator();
      document.body.style.userSelect = '';
    });
    row.addEventListener('dragover', e=>{
      e.preventDefault();
      showIndicatorAt(e.clientY);
    });
    row.addEventListener('drop', e=>{
      e.preventDefault();
      const from = parseInt(e.dataTransfer.getData('text/plain'));
      const rect = row.getBoundingClientRect();
      const before = e.clientY < rect.top + rect.height/2;
      insertPath(from, parseInt(row.dataset.index), before);
      removeIndicator();
    });
    pathList.appendChild(row);
  });
  if(paths.length === 0){
    const hint = document.createElement('div');
    hint.className = 'small-muted';
    hint.style.padding = '8px';
    hint.textContent = 'No strokes loaded â€” import SVG or paste JSON with trace_path.';
    pathList.appendChild(hint);
  }
}
function removeIndicator(){ pathList.querySelectorAll('.drop-indicator').forEach(x=>x.remove()); }
function showIndicatorAt(clientY){
  removeIndicator();
  const items = Array.from(pathList.querySelectorAll('.path-item'));
  if(items.length === 0){
    const ind = document.createElement('div'); ind.className = 'drop-indicator'; ind.style.top = '0px'; ind.dataset.pos = 0; pathList.appendChild(ind); return;
  }
  let insertPos = items.length;
  for(let i=0;i<items.length;i++){
    const r = items[i].getBoundingClientRect();
    if(clientY < r.top + r.height/2){ insertPos = i; break; }
  }
  const topPx = (insertPos < items.length) ? items[insertPos].offsetTop : pathList.scrollHeight;
  const ind = document.createElement('div'); ind.className = 'drop-indicator'; ind.style.top = topPx + 'px'; ind.dataset.pos = insertPos;
  pathList.appendChild(ind);
}
function insertPath(from,to,before){
  saveUndo();
  const moved = paths.splice(from,1)[0];
  let pos = to + (before?0:1);
  if(from < to) pos--;
  pos = clamp(pos, 0, paths.length);
  paths.splice(pos,0,moved);
  renderAll();
}

/* exposed controls for inline buttons */
window.moveUp = function(i){ if(i<=0) return; saveUndo(); [paths[i-1],paths[i]]=[paths[i],paths[i-1]]; renderAll(); }
window.moveDown = function(i){ if(i>=paths.length-1) return; saveUndo(); [paths[i+1],paths[i]]=[paths[i],paths[i+1]]; renderAll(); }
window.deletePath = function(i){ saveUndo(); paths.splice(i,1); renderAll(); }
window.reversePath = function(i){
  saveUndo();
  const d = paths[i];
  const tmp = document.createElementNS('http://www.w3.org/2000/svg','path');
  tmp.setAttribute('d', d);
  preview.appendChild(tmp);
  try{
    const L = tmp.getTotalLength();
    const samples = Math.min(400, Math.max(40, Math.round(L/2)));
    const pts = [];
    for(let s=0;s<=samples;s++){ const p = tmp.getPointAtLength((s/samples)*L); pts.push(`${p.x.toFixed(2)},${p.y.toFixed(2)}`); }
    paths[i] = 'M' + pts.reverse().join(' L');
  }catch(e){
    paths[i] = d.split('').reverse().join('');
  }
  tmp.remove();
  renderAll();
}

/* ====== Preview drawing (with overlays) ====== */
function drawPreview(){
  preview.innerHTML = '';
  preview.style.background = bg;

  // defs for classic markers
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  colors.forEach((c,idx)=>{
    const m = document.createElementNS('http://www.w3.org/2000/svg','marker');
    m.setAttribute('id', `arrow-${idx}`);
    m.setAttribute('markerWidth','10');
    m.setAttribute('markerHeight','10');
    m.setAttribute('refX','9');
    m.setAttribute('refY','3');
    m.setAttribute('orient','auto');
    m.setAttribute('markerUnits','strokeWidth');
    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('d','M0,0 L9,3 L0,6 Z');
    p.setAttribute('fill', c);
    m.appendChild(p);
    defs.appendChild(m);
  });
  preview.appendChild(defs);

  // draw base paths
  let bbox = null;
  const pathEls = [];
  for(let i=0;i<paths.length;i++){
    const d = paths[i];
    const color = colors[i%colors.length];
    const el = document.createElementNS('http://www.w3.org/2000/svg','path');
    el.setAttribute('d', d);
    el.setAttribute('fill', 'none');
    el.setAttribute('stroke', color);
    el.setAttribute('stroke-linecap', 'round');
    el.setAttribute('stroke-linejoin', 'round');
    el.setAttribute('stroke-width', strokeW);
    if(showArrows && strokeW <= 3) el.setAttribute('marker-end', `url(#arrow-${i%colors.length})`);
    preview.appendChild(el);
    pathEls.push(el);
    try{
      const b = el.getBBox();
      if(!bbox) bbox = { x: b.x, y: b.y, x2: b.x + b.width, y2: b.y + b.height };
      else { bbox.x = Math.min(bbox.x, b.x); bbox.y = Math.min(bbox.y, b.y); bbox.x2 = Math.max(bbox.x2, b.x + b.width); bbox.y2 = Math.max(bbox.y2, b.y + b.height); }
    }catch(e){}
  }

  if(!bbox){
    const nums = [...paths.join(' ').matchAll(/-?\\d+\\.?\\d*/g)].map(m=>+m[0]);
    if(nums.length){
      const xs = nums.filter((_,i)=>i%2===0), ys = nums.filter((_,i)=>i%2===1);
      bbox = { x: Math.min(...xs), y: Math.min(...ys), x2: Math.max(...xs), y2: Math.max(...ys) };
    }
  }

  if(bbox){
    const pad = Math.max(20, strokeW*2);
    preview.setAttribute('viewBox', `${bbox.x-pad} ${bbox.y-pad} ${(bbox.x2-bbox.x)+pad*2} ${(bbox.y2-bbox.y)+pad*2}`);
  } else {
    preview.setAttribute('viewBox', '0 0 300 300');
  }

  // overlays for strokeW > 3
  if(strokeW > 3){
    pathEls.forEach((el,i)=>{
      const base = colors[i%colors.length];
      const overlayColor = darkOverlay.has(base) ? '#ffffff' : '#000000';
      // dotted overlay line
      const overlay = document.createElementNS('http://www.w3.org/2000/svg','path');
      overlay.setAttribute('d', el.getAttribute('d'));
      overlay.setAttribute('fill', 'none');
      overlay.setAttribute('stroke', overlayColor);
      overlay.setAttribute('stroke-width', '1');
      overlay.setAttribute('stroke-dasharray', '4 4');
      overlay.setAttribute('pointer-events', 'none');
      preview.appendChild(overlay);
      // three fixed small arrows at 30/60/90
      try{
        const L = el.getTotalLength();
        [0.3,0.6,0.9].forEach(f=>{
          const pos = Math.max(0, Math.min(L, f*L));
          const pt = el.getPointAtLength(pos);
          const ahead = el.getPointAtLength(Math.min(L, pos + 1));
          const ang = Math.atan2(ahead.y - pt.y, ahead.x - pt.x);
          const s = 7; // fixed size
          const tri = document.createElementNS('http://www.w3.org/2000/svg','path');
          tri.setAttribute('d', `M ${pt.x - s} ${pt.y - s/2} L ${pt.x} ${pt.y} L ${pt.x - s} ${pt.y + s/2} Z`);
          tri.setAttribute('fill', overlayColor);
          tri.setAttribute('stroke', 'none');
          tri.setAttribute('transform', `rotate(${ang * 180 / Math.PI} ${pt.x} ${pt.y})`);
          tri.setAttribute('pointer-events', 'none');
          preview.appendChild(tri);
        });
      }catch(e){
        // ignore path length errors
      }
    });
  }
}

/* ====== Render (list + preview + json) ====== */
function renderAll(){
  renderList();
  drawPreview();
  updateJson();
}
renderAll();

/* ====== Controls ====== */
undoBtn.addEventListener('click', ()=>{ if(!undoStack.length) return; paths = JSON.parse(undoStack.pop()); renderAll(); });
resetBtn.addEventListener('click', ()=>{ if(!originalPaths.length) return; paths = originalPaths.slice(); renderAll(); });
clearBtn.addEventListener('click', ()=>{ paths = []; originalPaths = []; undoStack = []; pasteArea.value=''; fileInput.value=''; charInput.value=''; renderAll(); });
copyJson.addEventListener('click', ()=>{ navigator.clipboard.writeText(jsonOutput.textContent); copyJson.textContent='Copied!'; setTimeout(()=>copyJson.textContent='Copy JSON',900); });

strokeRange.addEventListener('input', e=>{ strokeW = parseFloat(e.target.value); strokeValue.textContent = strokeW; drawPreview(); });
bgColor.addEventListener('input', e=>{ bg = e.target.value; drawPreview(); });
showArrowsInput.addEventListener('change', e=>{ showArrows = e.target.checked; drawPreview(); });

// allow dropping on empty list area to move to bottom
pathList.addEventListener('dragover', e=>{ e.preventDefault(); showIndicatorAt(e.clientY); });
pathList.addEventListener('drop', e=>{
  e.preventDefault();
  const from = parseInt(e.dataTransfer.getData('text/plain'));
  const ind = pathList.querySelector('.drop-indicator');
  const pos = ind ? parseInt(ind.dataset.pos) : paths.length;
  saveUndo();
  const moved = paths.splice(from,1)[0];
  let target = pos;
  if(from < pos) target--;
  paths.splice(target,0,moved);
  renderAll();
  removeIndicator();
});

/* ====== Resizers ====== */
// vertical resize between preview and JSON
let startY, startTop, startBottom;
vDivider.addEventListener('mousedown', e=>{
  startY = e.clientY;
  startTop = previewContainer.offsetHeight;
  startBottom = jsonOutput.parentElement.offsetHeight;
  document.addEventListener('mousemove', onVMove);
  document.addEventListener('mouseup', onVUp);
});
function onVMove(e){
  const dy = e.clientY - startY;
  const total = startTop + startBottom;
  let newTop = clamp(startTop + dy, 120, total - 120);
  previewContainer.style.flex = '0 0 ' + newTop + 'px';
  jsonOutput.parentElement.style.flex = '0 0 ' + (total - newTop) + 'px';
}
function onVUp(){ document.removeEventListener('mousemove', onVMove); document.removeEventListener('mouseup', onVUp); }

// horizontal resize between left and right
let startX, startLeftWidth;
hDivider.addEventListener('mousedown', e=>{
  startX = e.clientX;
  startLeftWidth = leftPanel.offsetWidth;
  document.addEventListener('mousemove', onHMove);
  document.addEventListener('mouseup', onHUp);
});
function onHMove(e){
  const dx = e.clientX - startX;
  const newWidth = clamp(startLeftWidth + dx, 220, window.innerWidth - 320);
  leftPanel.style.width = newWidth + 'px';
}
function onHUp(){ document.removeEventListener('mousemove', onHMove); document.removeEventListener('mouseup', onHUp); }

/* ====== Drag indicator helpers (used above) ====== */
function showIndicatorAt(clientY){
  removeIndicator();
  const items = Array.from(pathList.querySelectorAll('.path-item'));
  if(items.length === 0){
    const ind = document.createElement('div'); ind.className = 'drop-indicator'; ind.style.top = '0px'; ind.dataset.pos = 0; pathList.appendChild(ind); return;
  }
  let insertPos = items.length;
  for(let i=0;i<items.length;i++){
    const r = items[i].getBoundingClientRect();
    if(clientY < r.top + r.height/2){ insertPos = i; break; }
  }
  const topPx = (insertPos < items.length) ? items[insertPos].offsetTop : pathList.scrollHeight;
  const ind = document.createElement('div'); ind.className = 'drop-indicator'; ind.style.top = topPx + 'px'; ind.dataset.pos = insertPos;
  pathList.appendChild(ind);
}

/* ====== End ====== */
</script>
</body>
</html>
